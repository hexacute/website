---
date: 2018-03-26
title: "Ã‰crire des high-order components rÃ©utilisables avec Recompose"
author: scastiel
oldSlug: js/react/hoc-reutilisables-recompose
slug: ecrire-des-high-order-components-reutilisables-avec-recompose
---

Ã‰crire des composants rÃ©utilisables est (ou devrait Ãªtre) lâ€™un des objectifs de
tout dÃ©veloppeur React. Que ce soit pour crÃ©er une boÃ®te Ã  outils de composants
stylÃ©s, pour mutualiser des comportements communs, etc.

MÃªme en ayant frÃ©quemment utilisÃ© des _high-order components_ (avec
_React-Redux_ par exemple), ce nâ€™est que rÃ©cemment que jâ€™ai entendu parler de
lâ€™opportunitÃ© quâ€™ils offraient pour Ã©crire des composants rÃ©utilisables, en
particulier grÃ¢ce Ã  une fantastique bibliothÃ¨que :
[Recompose](https://github.com/acdlite/recompose). Voyons comment avec un
exemple concret et complet.

Si vous nâ€™avez jamais entendu parler de _high-order components_ (HOC) avant,
sachez simplement quâ€™un HOC nâ€™est finalement rien dâ€™autre quâ€™une fonction qui
prend en paramÃ¨tre une dÃ©finition de composant (classe ou fonction), et renvoie
une nouvelle dÃ©finition de composant, qui ajoute du comportement Ã  la premiÃ¨re.
Il sâ€™agit en fait du pattern
[_DÃ©corateur_](https://en.wikipedia.org/wiki/Decorator_pattern) appliquÃ© aux
composants React.

Sur le site de React vous trouverez une
[page trÃ¨s fournie](https://reactjs.org/docs/higher-order-components.html) si
vous souhaitez en savoir plus sur les HOC. Il y a Ã©galement un
[trÃ¨s bon article sur Putain de code](/fr/articles/js/react/higher-order-component/#le-pattern-higher-order-component)
prÃ©sentant les HOC Ã  travers un autre cas dâ€™utilisation (le pattern _provider_).

Un exemple trÃ¨s simple :

```js
const addBorder = borderWidth => Component => props => (
  <div style={{ borderColor: "black", borderStyle: "solid", borderWidth }}>
    <Component {...props} />
  </div>
);

const MyText = <p>Hello!</p>;

const MyTextWithBorder = addBorder(5)(MyText);
```

Vous obtenez un composant `MyTextWithBorder` qui affiche le texte Â« Hello Â» avec
une bordure de 5 pixels. Ici, `addBorder` est ce que lâ€™on appelle un _high-order
component_.

Quel est lâ€™intÃ©rÃªt dâ€™un HOC ? Et bien un pattern trÃ¨s utile est dâ€™extraire un
comportement partagÃ© par plusieurs composants dans des fonctions rÃ©utilisables.
Si vous avez utilisÃ© React avec Redux et React-Redux, vous avez sans doute
utilisÃ© le HOC `connect` pour faire le mapping de lâ€™Ã©tat et des actions avec les
propriÃ©tÃ©s.

## Exemple : champ de saisie dâ€™un numÃ©ro de tÃ©lÃ©phone

Comme exemple complet pour cette article, nous allons utiliser le concept dâ€™HOC
pour crÃ©er un champ de saisie de numÃ©ro de tÃ©lÃ©phone, qui :

- nâ€™acceptera que les chiffres, parenthÃ¨ses, tirets et espaces en entrÃ©e (Ã  la
  frappe) ;
- mettra en forme le numÃ©ro de tÃ©lÃ©phone lorsque le focus sera perdu par le
  champ (Ã©vÃ¨nement _blur_). (Seuls les numÃ©ros de tÃ©lÃ©phone Nord-Americains
  seront pris en compte : Â« (514) 555-0199 Â».)

<figure>
  <img src="/public/images/articles/2018-03-26-ecrire-des-high-order-components-reutilisables-avec-recompose/phoneNumberInput.gif" alt="Champ de saisie de numÃ©ro de tÃ©lÃ©phone" />
  <figcaption>Notre champ de saisie de numÃ©ro de tÃ©lÃ©phone</figcaption>
</figure>

Notez que lâ€™on supposera que notre champs sera contrÃ´lÃ©, câ€™est-Ã -dire que nous
utiliserons les propriÃ©tÃ©s `value` et `onChange` pour savoir quel texte afficher
et comment le mettre Ã  jour. Nous souhaitons Ã©galement que la valeur ne
contienne que les chiffres du numÃ©ro de tÃ©lÃ©phone (Â« 5145550199 Â»), sans se
soucier de la mise en forme, et donc que le `onChange` soit appelÃ© avec les
chiffres uniquement (dans `event.target.value`).

Pour rendre notre HOC plus facile Ã  Ã©crire et maintenir, nous utiserons la
bibliothÃ¨que _Recompose_, qui propose un grand nombre de fonctions utilitaires
pour Ã©crire des HOC. Nous en verrons quelques-unes dans cet article.

Pour dÃ©velopper notre composant nous crÃ©erons deux HOC rÃ©utilisables, un pour
chacun des points ci-dessus. Cela signifie que nous souhaitons que notre
composant final soit dÃ©fini ainsi :

```js
const PhoneNumberInput = formatPhoneNumber(
  forbidNonPhoneNumberCharacters(props => <input {...props} />),
);
```

Câ€™est le bon moment pour introduire la premiÃ¨re fonction de _Recompose_ que nous
utiliserons : `compose`. Elle effectue la composition de plusieurs HOC pour les
fusionner en un seul, de sorte que nous pouvons Ã©crire plus simplement :

```js
const PhoneNumberInput = compose(
  formatPhoneNumber,
  forbidNonPhoneNumberCharacters,
)(props => <input {...props} />);
```

Et parce que nous souhaitons rendre nos HOC aussi rÃ©utilisable que possible
(pour mettre en forme autre chose que des numÃ©ros de tÃ©lÃ©phone par exemple),
rendons-les plus gÃ©nÃ©riques :

```js
// Ne garde que les chiffres, espaces, tirets et parenthÃ¨ses
const forbiddenCharactersInPhoneNumber = /[^\d\s\-()]/g;

// '5145551234' => '(514) 555-1234'
const formatPhoneNumber = value =>
  value.replace(/^(\d{3})(\d{3})(\d{4})$/, "($1) $2-$3");

// '(514) 555-1234' => '5145551234'
const parsePhoneNumber = formattedPhoneNumber =>
  formattedPhoneNumber.replace(/[^\d]/g, "").slice(0, 10);

const PhoneNumberInput = compose(
  formatInputValue({
    formatValue: formatPhoneNumber,
    parseValue: parsePhoneNumber,
  }),
  forbidCharacters(forbiddenCharactersInPhoneNumber),
)(props => <input {...props} />);
```

Ne trouvez-vous pas cela dÃ©jÃ  gÃ©nial si lâ€™on peut rÃ©utiliser uniquement nos deux
HOC pour mettre en forme des montants, des numÃ©ros de sÃ©curitÃ© sociale, tout et
nâ€™importe quoi, juste en utilisant les bons paramÃ¨tres ? ğŸ˜‰

Le point rÃ©ellement intÃ©ressant est quâ€™ici jâ€™utilise le composant `<input>` de
base, mais nous pourrions utiliser nâ€™importe quel composant, tant quâ€™il utilise
les propriÃ©tÃ©s `value`, `onChange` et `onBlur`. Donc on peut imaginer utiliser
notre champs de saisie de numÃ©ros de tÃ©lÃ©phone avec React Native, Material-UI,
etc.

Ok, maintenant passons au plus important, Ã©crire nos deux HOC en utilisant les
fonctions que Recompose nous met Ã  disposition.

## Premier HOC : nâ€™accepter que certains caractÃ¨res

Lâ€™idÃ©e ici est que lorsque la valeur de lâ€™input est changÃ©e (Ã©vÃ¨nement
`onChange`), on intercepte cet Ã©vÃ¨nement pour supprimer tout caractÃ¨re interdit
de la valeur, puis on appelle la propriÃ©tÃ© `onChange` parente avec la valeur
propre.

Nous utiliserons ici la fonction `withHandlers` pour ajouter des nouveaux
_handlers_ dâ€™Ã©vÃ¨nement comme propriÃ©tÃ©s du composant encapsulÃ©. Le bon point est
que nous avons accÃ¨s aux propriÃ©tÃ©s de notre composant (ici nous utiliserons
`onChange`) pour crÃ©er notre nouveau handler :

```js
const forbidCharacters = forbiddenCharsRegexp =>
  withHandlers({
    onChange: props => event => {
      // Nâ€™oublions pas que `onChange` nâ€™est pas une propriÃ©tÃ© requise
      // (mÃªme si rien ne se produira si elle est absente).
      if (props.onChange) {
        const value = event.target.value;
        const cleanValue = value.replace(forbiddenCharsRegexp, "");
        // On ne modifie pas lâ€™Ã©vÃ¨nement original, mais on le clone
        // en y redÃ©finissant event.target.value avec la valeur propre.
        const newEvent = {
          ...event,
          target: { ...event.target, value: cleanValue },
        };
        // On rÃ©Ã©met notre Ã©vÃ¨nement au `onChange` parent.
        props.onChange(newEvent);
      }
    },
  });
```

Souvenez-vous quâ€™autant que possible le composant que nous crÃ©ons Ã  partir dâ€™un
autre doit respecter lâ€™interface de ce dernier. Il doit donc accepter les mÃªmes
propriÃ©tÃ©s avec le mÃªme type.

Ã€ prÃ©sent si nous souhaitons par exemple crÃ©er un champ nâ€™acceptant que les
chiffres, nous pouvons Ã©crire :

```js
const NumericField = forbidCharacters(/[^\d]/g)(props => <input {...props} />);
```

Nous avons maintenant notre premier HOC pour interdire certains caractÃ¨res;
Ã©crivons Ã  prÃ©sent le deuxiÃ¨me, lÃ©gÃ¨rement plus complexe, pour mettre en forme
la valeur entrÃ©e par lâ€™utilisateur.

## DeuxiÃ¨me HOC : mettre en forme la valeur entrÃ©e

Pour notre deuxiÃ¨me HOC, nous devrons avoir dans notre composant un Ã©tat local
pour stocker la valeur entrÃ©e dans le champs sans la passer au composant parent.
Nâ€™oubliez pas que nous souhaitons mettre en forme la valeur uniquement lorsque
le focus sort du champs (Ã©vÃ¨nement _blur_).

Recompose dÃ©finit une fonction trÃ¨s simple pour ajouter un Ã©tat local Ã  un
composant : `withState`. Elle prend en paramÃ¨tre le nom de lâ€™attribut dans
lâ€™Ã©tat (qui sera donnÃ© comme propriÃ©tÃ© au composant enfant), le nom de la
propriÃ©tÃ© contenant la fonction pour mettre Ã  jour cet Ã©tat (Ã©galement donnÃ©e
comme propriÃ©tÃ©), et la valeur initiale (valeur statique, ou bien fonction
prenant en paramÃ¨tre les propriÃ©tÃ©s et retournant la valeur initiale).

Pour ajouter notre Ã©tat local nous Ã©crirons :

```js
withState(
  "inputValue",
  "setInputValue",
  // `formatValue` est lâ€™un des paramÃ¨tres de notre HOC
  props => formatValue(props.value),
);
```

Facile, non ? ğŸ˜‰

Maintenant que lâ€™on a notre Ã©tat, nous devons le mettre Ã  jour lorsque la valeur
de lâ€™input est modifiÃ©e, donc nous dÃ©finirons un handler `onChange` personnalisÃ©
:

```js
withHandlers({
  onChange: props => event => {
    props.setInputValue(event.target.value)
  }
  // ...
```

Et Ã  lâ€™Ã©vÃ¨nement _blur_, nous mettrons en forme la valeur, appelerons les
`onChange` et `onBlur` parents, puis mettrons en forme Ã©galement la valeur
affichÃ©e :

```js
  // ...
  onBlur: props => event => {
    // parseValue est lâ€™autre paramÃ¨tre de notre HOC
    const parsedValue = parseValue(props.inputValue)
    const formattedValue = formatValue(parsedValue)
    props.setInputValue(formattedValue)
    // On ne modifie pas lâ€™Ã©vÃ¨nement original, mais on le clone
    // en y redÃ©finissant event.target.value avec la valeur propre.
    const newEvent = {
      ...event,
      target: { ...event.target, value: parsedValue }
    }
    if (props.onChange) {
      props.onChange(newEvent)
    }
    if (props.onBlur) {
      props.onBlur(newEvent)
    }
  }
)
```

La derniÃ¨re Ã©tape pour notre HOC consiste Ã  nous assurer que seules les
propriÃ©tÃ©s acceptÃ©es par `<input>` lui seront passÃ©es. Pour cela on utilisera la
fonction `mapProps` de Recompose pour crÃ©er un nouvel objet de propriÃ©tÃ©s Ã 
partir des propriÃ©tÃ©s existantes, ainsi que la fonction `omit` de _lodash_ pour
exclure certaines propriÃ©tÃ©s dâ€™un objet pour en crÃ©er un nouveau :

```js
mapProps(props => ({
  ...omit(props, ["inputValue", "setInputValue"]),
  value: props.inputValue,
}));
```

En assemblant le tout avec `compose`, on obtient :

```js
const formatInputValue = ({ formatValue, parseValue }) =>
  compose(
    withState("inputValue", "setInputValue", props => formatValue(props.value)),
    withHandlers({
      onChange: props => event => {
        props.setInputValue(event.target.value);
      },
      onBlur: props => event => {
        const parsedValue = parseValue(props.inputValue);
        const formattedValue = formatValue(parsedValue);
        props.setInputValue(formattedValue);
        const newEvent = {
          ...event,
          target: { ...event.target, value: parsedValue },
        };
        if (props.onChange) {
          props.onChange(newEvent);
        }
        if (props.onBlur) {
          props.onBlur(newEvent);
        }
      },
    }),
    mapProps(props => ({
      ...omit(props, ["inputValue", "setInputValue"]),
      value: props.inputValue,
    })),
  );
```

Et voilÃ  ! Nous avons deux _high-order components_, on peut les utiliser pour
crÃ©er notre champs de saisie de numÃ©ro de tÃ©lÃ©phone ! Ci-dessous vous trouverez
le JSFiddle content le code source complet de cet exemple, et vous permet de
tester le rÃ©sultat. Nâ€™hÃ©sitez pas Ã  forker le
[JSFiddle](https://jsfiddle.net/scastiel/prme4k6L/) pour jouer avec Recompose ou
crÃ©er vos propres HOC.

<iframe width="100%" height="300" src="//jsfiddle.net/scastiel/prme4k6L/8/embedded/js,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

## Les _render props_ : une alternative aux _high-order components_ ?

Ã‰crire des composants rÃ©utilisables est tout Ã  fait possible sans utiliser de
HOC. Pour reprendre notre exemple de champ de saisie de numÃ©ro de tÃ©lÃ©phone nous
pourrions crÃ©er un composant `FormattedInput`, qui prendrait en paramÃ¨tres
(propriÃ©tÃ©) les caractÃ¨res autorisÃ©s dâ€™une part, et les fonctions de formattage
dâ€™autre part. Il resterait un inconvÃ©nient Ã  cette mÃ©thode : cela vous contraint
Ã  nâ€™utiliser quâ€™un type de champ fixÃ© Ã  lâ€™avance, par exemple `<input>`.

Câ€™est lÃ  quâ€™intervient un concept particuliÃ¨rement intÃ©ressant : celui des
_render props_. Tout simplement, cela consiste Ã  passer en propriÃ©tÃ© de votre
composant une fonction permettant de gÃ©nÃ©rer un autre composant, qui sera une
composante du premier.

Par exemple notre `PhoneNumberInput` pourrait nous laisser la possibilitÃ© de lui
indiquer comment gÃ©nÃ©rer un champ de saisie (sur lequel il ajoutera le
comportement spÃ©cifique, ici la mise en forme) :

```js
<PhoneNumberInput renderInput={inputProps => <input {...inputProps} />} />
```

Il y aurait de quoi Ã©crire un article entier sur les _render props_, et selon
moi il serait dommage de les voir comme une sorte de Â« concurrent Â» des HOC ;
les deux peuvent rÃ©pondre Ã  des problÃ©matiques parfois similaires, parfois
diffÃ©rentes.

Pour en savoir plus sur les _render props_ la
[page consacrÃ©e de la documentation de React](https://reactjs.org/docs/render-props.html)
est trÃ¨s dÃ©taillÃ©e et donne Ã©galement de bons exemples dâ€™utilisation.

## En conclusionâ€¦

Jâ€™espÃ¨re que cet article vous a donnÃ© envie dâ€™en savoir plus Ã  propos de
Recompose et des _high-order components_ en gÃ©nÃ©ral. Je suis convaincu que les
HOC crÃ©ent une nouvelle maniÃ¨re dâ€™Ã©crire des composants rÃ©utilisables ; on en
entendra sans aucun doute parler de plus en plus dans le futur ğŸ˜€.

Quelques ressources pour aller plus loin :

- La
  [documentation de lâ€™API de Recompose](https://github.com/acdlite/recompose/blob/master/docs/API.md)
  est assez complÃ¨te, bien que selon moi elle manque parfois dâ€™exemples pour
  comprendre certaines fonctions complexes ;
- La
  [page de React Ã  propos des HOC](https://reactjs.org/docs/higher-order-components.html)
  contient un grand nombre dâ€™informations, par exemple ce que vous ne devriez
  pas faire avec les HOC ğŸ˜‰ ;
- [React Higher Order Components in depth](https://medium.com/@franleplant/react-higher-order-components-in-depth-cf9032ee6c3e)
  : une trÃ¨s bonne introduction aux HOC ;
- [Why The Hipsters Recompose Everything](https://medium.com/javascript-inside/why-the-hipsters-recompose-everything-23ac08748198)
  : une introduction sympa Ã  Recompose (semble un peu datÃ©eâ€¦).
- [La documentation de React sur les _render props_](https://reactjs.org/docs/render-props.html)
- [Les patterns Provider & Higher-Order Component avec React](/fr/articles/js/react/higher-order-component/#le-pattern-higher-order-component)
  sur Putain de code

_Cet article est (pour la plus grande partie) la traduction en franÃ§ais de mon
article initialement en anglais disponible sur mon blog :
[Create reusable high-order React components with Recompose](https://blog.castiel.me/posts/006-reusable-hoc-with-recompose.html)._
