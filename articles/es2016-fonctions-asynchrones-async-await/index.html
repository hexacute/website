<!DOCTYPE html><html ><head><title data-react-helmet="true">ES2016 (?): fonctions asynchrones (async/await) | Putain de code</title><meta data-react-helmet="true" charset="UTF-8"/><meta data-react-helmet="true" name="description" value="Blog participatif de la communauté dev"/><meta data-react-helmet="true" content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/><meta data-react-helmet="true" content="summary_large_image" name="twitter:card"/><meta data-react-helmet="true" content="Putain de code !" property="og:site_name"/><meta data-react-helmet="true" content="@putaindecode" name="twitter:site"/><meta data-react-helmet="true" content="Putain de code" property="og:title"/><meta data-react-helmet="true" content="Putain de code" name="twitter:title"/><meta data-react-helmet="true" content="https://putaindecode.io/public/images/website/share.jpg" property="og:image"/><meta data-react-helmet="true" content="https://putaindecode.io/public/images/website/share.jpg" name="twitter:image"/><meta data-react-helmet="true" content="1500" property="og:image:width"/><meta data-react-helmet="true" content="777" property="og:image:height"/><link data-react-helmet="true" title="RSS Feed" href="/api/articles/feeds/desc/feed.xml" rel="alternate" type="application/rss+xml"/><link data-react-helmet="true" href="/favicon.ico" rel="shortcut icon"/><link data-react-helmet="true" href="https://putaindecode.io/articles/es2016-fonctions-asynchrones-async-await" rel="canonical"/><script>window.PAGES_BOOT_MODE="hydrate";</script></head><div id="root"><style data-emotion-rpcss="cv6q29 cqg32g vfl2jy 94ols9 1plrth7 1qdfdal">@-webkit-keyframes animation-cv6q29{0%{opacity:0;-webkit-transform:translateY(20px);-ms-transform:translateY(20px);transform:translateY(20px);}}@keyframes animation-cv6q29{0%{opacity:0;-webkit-transform:translateY(20px);-ms-transform:translateY(20px);transform:translateY(20px);}}body{padding:0;margin:0;background-color:#fff;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Roboto","Oxygen","Ubuntu","Cantarell","Fira Sans","Droid Sans","Helvetica Neue",sans-serif;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;min-height:100vh;overflow-x:hidden;}@media (prefers-color-scheme:dark){body{background-color:#222;}}#root{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}html{color:#46515B;font-size:1em;line-height:1.4;-webkit-font-smoothing:antialiased;-webkit-text-size-adjust:100%;}@media (prefers-color-scheme:dark){html{color:#ddd;}}a{color:#CC0613;-webkit-text-decoration:underline;text-decoration:underline;}@media (prefers-color-scheme:dark){a{color:#F87098;}}a:hover{-webkit-text-decoration:none;text-decoration:none;}*,*:before,*:after{box-sizing:border-box;}</style><style data-emotion-rpcss="u6xx5u">.rpcss-u6xx5u{background-color:#000;padding:10px;color:#fff;text-align:center;}</style><div class="rpcss-u6xx5u"><style data-emotion-rpcss="fyih5c">.rpcss-fyih5c{font-size:24px;font-weight:700;}</style><div class="rpcss-fyih5c" role="heading">Black Lives Matter</div><div><style data-emotion-rpcss="th8dfi">.rpcss-th8dfi{font-size:20px;color:#8CBEF9;}</style><a class="rpcss-th8dfi" href="https://blacklivesmatters.carrd.co/#">Comment aider</a> • <a class="rpcss-th8dfi" href="https://minnesotafreedomfund.org">Minnesota Freedom Fund</a> • <a class="rpcss-th8dfi" href="https://www.okpal.com/adama-traore/#/">Justice Pour Adama</a></div></div><style data-emotion-rpcss="1s4nnc7">.rpcss-1s4nnc7{background-color:#CC0613;background-image:linear-gradient(135deg,#E51D58 0%,#CC0613 100%);}</style><header class="rpcss-1s4nnc7" style="background-image:linear-gradient(to bottom right, hsl(83, 100%, 35%), hsl(69, 100%, 30%))"><style data-emotion-rpcss="qx7dny">.rpcss-qx7dny{width:100%;max-width:1024px;margin:0 auto;padding:0 10px;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;}</style><div class="rpcss-qx7dny"><style data-emotion-rpcss="7s9om2">.rpcss-7s9om2{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;padding:20px 0 50px;}</style><div class="rpcss-7s9om2"><style data-emotion-rpcss="gdpa5c">.rpcss-gdpa5c{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-text-decoration:none;text-decoration:none;}</style><a class="rpcss-gdpa5c" href="/"><style data-emotion-rpcss="1lm4738">.rpcss-1lm4738{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-text-decoration:none;text-decoration:none;padding-bottom:10px;}</style><div class="rpcss-1lm4738"><style data-emotion-rpcss="13o7eu2">.rpcss-13o7eu2{display:block;}</style><svg class="rpcss-13o7eu2" height="36px" width="36px" viewBox="0 0 36 36"><defs><linearGradient id="PutainDeCodeLogoGradient" x1="50%" x2="50%" y1="0%" y2="127.223881%"><stop offset="0%" stop-color="#E41D57"></stop><stop offset="100%" stop-color="#C60000"></stop></linearGradient></defs><circle cx="18" cy="18" fill="url(#PutainDeCodeLogoGradient)" r="17" stroke="#FFFFFF" stroke-width="2"></circle><polygon fill="#FFFFFF" points="15.9033203 18.2246094 15.9033203 18.3710938 11.2304688 20.5317383 11.2304688 22.8095703 18.0566406 19.184082 18.0566406 17.4116211 11.2304688 13.7788086 11.2304688 16.0639648"></polygon><rect height="14" width="2" fill="#FFFFFF" x="22" y="11"><animate attributeName="opacity" begin="100ms" calcMode="discrete" dur="2s" repeatCount="indefinite" values="1;0"></animate></rect></svg><style data-emotion-rpcss="4cf197">.rpcss-4cf197{width:10px;height:10px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;}</style><div class="rpcss-4cf197"></div><style data-emotion-rpcss="u5k24">.rpcss-u5k24{font-size:22px;color:#fff;font-weight:800;}</style><div aria-level="2" class="rpcss-u5k24" role="heading">Putain de code !</div></div><style data-emotion-rpcss="1nyebg4">.rpcss-1nyebg4{font-size:14px;color:rgba(255,255,255,0.8);text-align:center;}</style><div class="rpcss-1nyebg4">Blog participatif de la communauté dev</div></a></div></div></header><style data-emotion-rpcss="kcj2v3">.rpcss-kcj2v3{background-color:#F9F6F6;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}@media (prefers-color-scheme:dark){.rpcss-kcj2v3{background-color:#111;}}</style><div class="rpcss-kcj2v3"><style data-emotion-rpcss="ees1g6">.rpcss-ees1g6{-webkit-animation:animation-cv6q29 500ms ease-out 0ms 1 normal none running;animation:animation-cv6q29 500ms ease-out 0ms 1 normal none running;}</style><div class="rpcss-ees1g6"><div class="rpcss-qx7dny"><style data-emotion-rpcss="1qc2bam">.rpcss-1qc2bam{font-size:42px;font-weight:800;text-align:center;padding-top:40px;line-height:1.2;margin:0;}</style><h1 class="rpcss-1qc2bam">ES2016 (?): fonctions asynchrones (async/await)</h1><style data-emotion-rpcss="4ach9y">.rpcss-4ach9y{font-size:16px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;padding-top:10px;padding-bottom:40px;color:#46515B;-webkit-text-decoration:none;text-decoration:none;}@media (prefers-color-scheme:dark){.rpcss-4ach9y{color:#ccc;}}</style><a class="rpcss-4ach9y" href="https://github.com/naholyr"><style data-emotion-rpcss="uco8i7">.rpcss-uco8i7{width:32px;height:32px;border-radius:100%;margin-right:10px;}</style><img class="rpcss-uco8i7" alt="naholyr" src="https://avatars.githubusercontent.com/naholyr?size=64"/><div>naholyr<!-- --> <!-- -->•<!-- --> <time dateTime="Mon, 14 Dec 2015 00:00:00 GMT">2015/12/14</time></div></a><style data-emotion-rpcss="1ow2283">.rpcss-1ow2283{max-width:640px;width:100%;font-size:18px;margin:0 auto;line-height:1.7;}.rpcss-1ow2283 h2,.rpcss-1ow2283 h3,.rpcss-1ow2283 h4,.rpcss-1ow2283 h5,.rpcss-1ow2283 h6{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Roboto","Oxygen","Ubuntu","Cantarell","Fira Sans","Droid Sans","Helvetica Neue",sans-serif;font-weight:800;line-height:1.2;}.rpcss-1ow2283 img{max-width:100%;background-color:rgba(255,255,255,0.75);}.rpcss-1ow2283 code{font-size:0.9em;font-family:PragmataPro,SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;line-height:1;background-color:#FAF3E1;margin:0 0.2em;}@media (prefers-color-scheme:dark){.rpcss-1ow2283 code{background-color:#4F3804;}}.rpcss-1ow2283 pre{padding:10px;overflow-x:auto;font-size:14px;border-radius:10px;border:2px solid rgba(0,0,0,0.1);-webkit-overflow-scrolling:touch;}@media (prefers-color-scheme:dark){.rpcss-1ow2283 pre{border:2px solid rgba(255,255,255,0.1);}}.rpcss-1ow2283 pre code{font-size:14px;background-color:transparent;margin:0;}.rpcss-1ow2283 blockquote{padding-left:20px;margin:0;font-size:16px;border-left:3px solid rgba(0,0,0,0.4);font-style:italic;}.rpcss-1ow2283 .hljs-keyword{color:#DA6BB5;}.rpcss-1ow2283 .hljs-constructor{color:#DD792B;}.rpcss-1ow2283 .hljs-identifier{color:#1E9EA7;}.rpcss-1ow2283 .hljs-module-identifier{color:#C84682;}.rpcss-1ow2283 .hljs-string{color:#3BA1C8;}.rpcss-1ow2283 .hljs-comment{color:#aaa;}.rpcss-1ow2283 .hljs-operator{color:#DA6BB5;}.rpcss-1ow2283 .hljs-attribute{color:#4CB877;}.rpcss-1ow2283 table{width:100%;text-align:center;}.rpcss-1ow2283 figure{padding:20px 0;}.rpcss-1ow2283 figcaption{text-align:center;}.rpcss-1ow2283 a{overflow-wrap:break-word;}.rpcss-1ow2283 table thead th{background-color:#E4EBEE;padding:10px 0;}</style><div class="rpcss-1ow2283"><p>Aujourd'hui, une fonctionnalité peut-être abusivement taggée &quot;ES6&quot; puisqu'elle
ne fait pas partie des propositions acceptées cette année : les fonctions
asynchrones (async/await). La
<a href="https://tc39.github.io/ecmascript-asyncawait/">spécification</a> est encore au
stade 3 (candidate) à l'heure de cet article. Mais il ne fait plus aucun doute
qu'elle (ou une variante) fera partie de la spécification ES2016.</p>
<h2>Fonctions asynchrones</h2>
<p>Pour les traitements asynchrones, vous connaissez déjà
<a href="/fr/articles/js/es2015/promises/">les promesses</a> qui ont évidemment remplacé
les callbacks dans votre code. Si vous n'avez pas déjà fait la bascule vers les
promesses (ne serait-ce que pour la propagation d'erreur),
<a href="/fr/articles/js/es2015/generators/">les générateurs</a> ont dû finir de vous
convaincre grâce aux
<a href="/fr/articles/js/es2015/generators/#use-case-co-routines">coroutines</a>.</p>
<p>Nous allons voir aujourd'hui une nouvelle manière de traiter les fonctions
asynchrones. Mais ne jetez pas vos promesses, tout tourne encore autour d'elles.</p>
<h2>Exemple de traitement asynchrone : Promise</h2>
<p>Partons du programme suivant exécuté le 6 décembre dernier dont l'API est basée
sur les promesses :</p>
<ul>
<li>Il récupère tous les utilisateurs prénommés Nicolas</li>
<li>Il envoie un mail à chacun pour souhaiter bonne fête</li>
</ul>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendEmails</span>(<span class="hljs-params">query</span>) </span>{
  <span class="hljs-keyword">const</span> usersP = getUsers(query);
  <span class="hljs-comment">// On récupère le champ &quot;email&quot; de tous les utilisateurs</span>
  <span class="hljs-keyword">const</span> emailsP = usersP.then(<span class="hljs-function"><span class="hljs-params">users</span> =&gt;</span> users.map(<span class="hljs-function"><span class="hljs-params">u</span> =&gt;</span> u.email));
  <span class="hljs-comment">// Pour chaque email…</span>
  <span class="hljs-keyword">const</span> sentP = emailsP.then(<span class="hljs-function"><span class="hljs-params">emails</span> =&gt;</span>
    emails.map(<span class="hljs-function"><span class="hljs-params">email</span> =&gt;</span> {
      <span class="hljs-comment">// … on envoie un mail</span>
      <span class="hljs-keyword">return</span> sendMail(email, <span class="hljs-string">&quot;Bonne fête&quot;</span>);
    }),
  );
  <span class="hljs-comment">// On attend que tous les envois soient résolus</span>
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all(sentP);
}

sendEmails({ <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;Nicolas&quot;</span> })
  .then(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;OK&quot;</span>))
  .catch(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&quot;FAIL&quot;</span>));
</code></pre>
<h2>Nouveaux mot-clés <code>async</code> et <code>await</code></h2>
<p>Une fonction peut être marquée comme asynchrone lorsque préfixée par <code>async</code> :</p>
<pre><code class="language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// …</span>
}
</code></pre>
<p>Dans une fonction asynchrone, et <strong>seulement</strong> dans une fonction asynchrone, le
mot-clé <code>await</code> devient disponible. Lorsqu'il est utilisé en préfixe d'une
promesse, l'évaluation de l'expression est &quot;mise en pause&quot; jusqu'à la résolution
(ou le rejet) de la promesse :</p>
<pre><code class="language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">await</span> aPromise;
  <span class="hljs-comment">// on n&#x27;arrivera à cette ligne que lorsque &quot;aPromise&quot; sera résolue</span>
}
</code></pre>
<p>Évidemment, l'expression a alors pour valeur celle de résolution de la promesse,
et en cas d'erreur l'expression va lever (<code>throw</code>) une erreur :</p>
<pre><code class="language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> aPromise;
    <span class="hljs-comment">// Ici &quot;aPromise&quot; est résolue avec la valeur &quot;result&quot;</span>
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-comment">// Ici &quot;aPromise&quot; est rejetée avec l&#x27;erreur &quot;err&quot;</span>
  }

  <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; <span class="hljs-comment">// cette ligne n&#x27;est atteinte qu&#x27;après résolution/rejet</span>
}
</code></pre>
<p>Concrètement, si vous vous souvenez de l'article sur les générateurs et de la
partie sur les coroutines, remplacez <code>async function</code> par <code>function *</code> et
<code>await</code> par <code>yield</code>, et vous avez compris le principe. ;)</p>
<h2>Notre premier exemple, avec les fonctions asynchrones</h2>
<p>Réécrivons notre premier exemple avec des fonctions asynchrones :</p>
<pre><code class="language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendEmails</span>(<span class="hljs-params">query</span>) </span>{
  <span class="hljs-keyword">const</span> users = <span class="hljs-keyword">await</span> getUsers(query);
  <span class="hljs-keyword">const</span> emails = users.map(<span class="hljs-function"><span class="hljs-params">u</span> =&gt;</span> u.email);
  <span class="hljs-keyword">const</span> sentP = emails.map(<span class="hljs-function"><span class="hljs-params">email</span> =&gt;</span> sendMail(email, <span class="hljs-string">&quot;Bonne fête&quot;</span>));
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(sentP);
}

<span class="hljs-comment">// Attention, on ne peut pas utiliser &quot;await&quot; hors d&#x27;une fonction &quot;async&quot;</span>
<span class="hljs-comment">// il faut donc &quot;wrapper&quot; notre code autour d&#x27;une fonction asynchrone</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">await</span> sendEmails({ <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;Nicolas&quot;</span> });
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;OK&quot;</span>);
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&quot;FAIL&quot;</span>);
  }
}

main();
</code></pre>
<p>Mieux ? Moins bien ? Question de goût, mais on retrouve un code impératif plus
habituel.</p>
<h2>Attention au piège de l'exécution en série !</h2>
<p>Prenons l'exemple de requêtes qu'on exécute en concurrence avant d'utiliser
leurs résultats :</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> xP = getX(); <span class="hljs-comment">// Requête Ajax</span>
<span class="hljs-keyword">const</span> yP = getY(); <span class="hljs-comment">// Requête BDD</span>
<span class="hljs-keyword">const</span> resultP = <span class="hljs-built_in">Promise</span>.all([xP, yP]).then(sum);
</code></pre>
<p>Dans cet exemple, les requêtes sont lancées, exécutées en parallèle puis leurs
retours attendus avant de passer à la suite.</p>
<p>Si on le traduit bêtement ainsi, on perd l'aspect concurrentiel :</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> x = <span class="hljs-keyword">await</span> getX() <span class="hljs-comment">// Requête Ajax…</span>
<span class="hljs-comment">// … requête terminée !</span>
<span class="hljs-keyword">const</span> y = <span class="hljs-keyword">await</span> getY() <span class="hljs-comment">// Requête BDD…</span>
<span class="hljs-comment">// … requête terminée !</span>
<span class="hljs-keyword">const</span> result = sum([x, y])
</code></pre>
<p>Il faudra bien distinguer le moment où on souhaite <strong>démarrer l'action</strong> et le
moment où l'on souhaite <strong>disposer de son résultat</strong>, il y a plusieurs manières
de résoudre le problème, qui dépendent essentiellement du goût du développeur ;)</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> xP = getX() <span class="hljs-comment">// Requête Ajax démarrée…</span>
<span class="hljs-keyword">const</span> yP = getY() <span class="hljs-comment">// Requête BDD démarrée…</span>

<span class="hljs-comment">// Version 1 :</span>
<span class="hljs-keyword">const</span> x = <span class="hljs-keyword">await</span> xP <span class="hljs-comment">// …requête Ajax terminée !</span>
<span class="hljs-keyword">const</span> y = <span class="hljs-keyword">await</span> yP <span class="hljs-comment">// …requête BDD terminée !</span>
<span class="hljs-keyword">const</span> result = sum([x, y])

<span class="hljs-comment">// Version 2 avec un tableau :</span>
<span class="hljs-keyword">const</span> vars = [<span class="hljs-keyword">await</span> xP, <span class="hljs-keyword">await</span> yP]
<span class="hljs-keyword">const</span> result = sum(vars)

<span class="hljs-comment">// Version 3 avec Promise.all :</span>
<span class="hljs-keyword">const</span> vars = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all([xP, yP])
<span class="hljs-keyword">const</span> result = sum(vars)
</code></pre>
<h2>Et aujourd'hui ?</h2>
<p>On peut utiliser Babel pour compiler son code utilisant <code>async/await</code> en un code
basé sur les générateurs : il vous suffira d'ajouter les plugins Babel
<code>syntax-async-functions</code> et <code>transform-async-to-generator</code> (attention à inclure
<code>babel-polyfill</code> en fichier d'entrée).</p>
<h2>Conclusion</h2>
<p>Grâce aux fonctions asynchrones, la refactorisation d'un code bloquant vers un
code non bloquant devient vraiment aisée. Les promesses simplifiaient déjà le
processus mais on n'était pas débarassé des callbacks. Là, à deux mot-clés près,
c'est exactement la même chose !</p>
<p>D'un certain côté, c'est un retour en arrière : l'asynchrone mène aux promesses,
qui mènent à la programmation fonctionnelle, qui apporte tant de bienfaits… Il
s'agira de trouver le bon équilibre, je ne suis pas convaincu d'abandonner mes
<code>.then</code> tout de suite, mais il est certain que c'est une véritable avancée pour
ce langage : la courbe d'apprentissage des traitements asynchrones va être
drastiquement aplanie ;)</p>
</div><style data-emotion-rpcss="v01ydp">.rpcss-v01ydp{max-width:640px;width:100%;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;margin:20px auto;padding:20px;background-color:#fff;border-radius:10px;box-shadow:0 15px 15px -5px rgba(0,0,0,0.2);}@media (prefers-color-scheme:dark){.rpcss-v01ydp{background-color:#222;}}@media (max-width:540px){.rpcss-v01ydp{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}}</style><div class="rpcss-v01ydp"><style data-emotion-rpcss="ty7r4z">.rpcss-ty7r4z{font-weight:800;}</style><div class="rpcss-ty7r4z">Vous avez aimé cet article?</div><style data-emotion-rpcss="bb4ce3">.rpcss-bb4ce3{width:0px;height:10px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;}</style><div class="rpcss-bb4ce3"></div><style data-emotion-rpcss="1pkr03v">.rpcss-1pkr03v{background-color:#00aced;color:#fff;padding:10px 20px;-webkit-text-decoration:none;text-decoration:none;border-radius:5px;font-weight:800;}.rpcss-1pkr03v:active{opacity:0.5;}</style><a class="rpcss-1pkr03v" href="https://www.twitter.com/intent/tweet?text=ES2016%20(%3F)%3A%20fonctions%20asynchrones%20(async%2Fawait)%20sur%20%40PutainDeCode%20https%3A%2F%2Fputaindecode.io%2Farticles%2Fes2016-fonctions-asynchrones-async-await" target="_blank">Le partager sur Twitter</a></div><style data-emotion-rpcss="x4iqxe">.rpcss-x4iqxe{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;text-align:center;padding:20px;}</style><div class="rpcss-x4iqxe"><style data-emotion-rpcss="gein6x">.rpcss-gein6x{font-size:20px;-webkit-text-decoration:none;text-decoration:none;color:#1E49B5;}</style><a class="rpcss-gein6x" href="/articles">← Articles</a></div><style data-emotion-rpcss="8bodgl">.rpcss-8bodgl{max-width:640px;width:100%;margin:0 auto;padding:20px 0;}</style><div class="rpcss-8bodgl" id="disqus_thread"></div></div></div></div><div class="rpcss-qx7dny"><style data-emotion-rpcss="5518eg">.rpcss-5518eg{margin-top:20px;margin-bottom:20px;background-color:#E4EBEE;border-radius:10px;padding:20px;}@media (prefers-color-scheme:dark){.rpcss-5518eg{background-color:#111;}}</style><div class="rpcss-5518eg"><style data-emotion-rpcss="1gz1i1h">.rpcss-1gz1i1h{font-size:32px;font-weight:800;margin-bottom:20px;text-align:center;}</style><div aria-level="2" class="rpcss-1gz1i1h" role="heading">Ne rien rater</div><style data-emotion-rpcss="1wbispj">.rpcss-1wbispj{font-size:18px;margin-bottom:10px;text-align:center;}</style><div aria-level="3" class="rpcss-1wbispj" role="heading">Sur les réseaux</div><style data-emotion-rpcss="1hyoz7m">.rpcss-1hyoz7m{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;}</style><div class="rpcss-1hyoz7m"><a href="https://twitter.com/PutainDeCode"><img alt="Twitter" height="48" src="/public/images/website/twitter.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://facebook.com/putaindecode"><img alt="Facebook" height="48" src="/public/images/website/facebook.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://github.com/putaindecode"><img alt="Facebook" height="48" src="/public/images/website/github.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://itunes.apple.com/fr/podcast/putain-de-code-!/id1185311825"><img alt="Apple Podcast" height="48" src="/public/images/website/apple-podcast.svg" width="48"/></a><div class="rpcss-4cf197"></div><a href="https://soundcloud.com/putaindecode"><img alt="Soundcloud" height="48" src="/public/images/website/soundcloud.svg" width="48"/></a></div><div aria-level="3" class="rpcss-1wbispj" role="heading">Sur le chat</div><div class="rpcss-1hyoz7m"><a href="https://discord.gg/jtbGNNc"><img alt="Discord" height="48" src="/public/images/website/discord.svg" width="48"/></a></div></div></div><style data-emotion-rpcss="zs8kw7">.rpcss-zs8kw7{background-color:#222;padding:20px 0;}</style><footer class="rpcss-zs8kw7"><div class="rpcss-qx7dny"><style data-emotion-rpcss="79elbk">.rpcss-79elbk{position:relative;}</style><div class="rpcss-79elbk"><style data-emotion-rpcss="1hle0ni">.rpcss-1hle0ni{position:absolute;left:0;top:50%;color:#fff;-webkit-transform:translateY(-50%);-ms-transform:translateY(-50%);transform:translateY(-50%);-webkit-text-decoration:none;text-decoration:none;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><a class="rpcss-1hle0ni" href="/api/articles/feeds/desc/feed.xml"><style data-emotion-rpcss="lvyu5j">.rpcss-lvyu5j{margin-right:10px;}</style><img class="rpcss-lvyu5j" alt="Flux RSS" height="16" src="/public/images/website/rss-feed.svg" width="16"/><style data-emotion-rpcss="um3i31">@media (max-width:400px){.rpcss-um3i31{display:none;}}</style><div class="rpcss-um3i31">Flux RSS</div></a><style data-emotion-rpcss="12cp4l7">.rpcss-12cp4l7{color:rgba(255,255,255,0.5);text-align:center;font-size:14px;}</style><div class="rpcss-12cp4l7">© 2020 Putain de code !</div><style data-emotion-rpcss="1y2rkzl">.rpcss-1y2rkzl{position:absolute;right:0;top:50%;-webkit-transform:translateY(-50%);-ms-transform:translateY(-50%);transform:translateY(-50%);color:#fff;-webkit-text-decoration:none;text-decoration:none;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><a class="rpcss-1y2rkzl" href="https://github.com/putaindecode/putaindecode.io">GitHub</a></div></div></footer></div><script id="initialData" type="text/data">{"lists":{"RE_PRIVATE_NONE":true},"items":{"k":"articles","v":{"k":"es2016-fonctions-asynchrones-async-await","v":{"_0":{"TAG":0,"_0":{"slug":"es2016-fonctions-asynchrones-async-await","filename":"2015-12-14-es2016-fonctions-asynchrones-async-await","title":"ES2016 (?): fonctions asynchrones (async/await)","date":"Mon, 14 Dec 2015 00:00:00 GMT","draft":false,"meta":{"date":"2015-12-14T00:00:00.000Z","title":"ES2016 (?): fonctions asynchrones (async/await)","author":"naholyr","oldSlug":"js/es2016/async-await","slug":"es2016-fonctions-asynchrones-async-await"},"body":"<p>Aujourd'hui, une fonctionnalité peut-être abusivement taggée &quot;ES6&quot; puisqu'elle\nne fait pas partie des propositions acceptées cette année : les fonctions\nasynchrones (async/await). La\n<a href=\"https://tc39.github.io/ecmascript-asyncawait/\">spécification</a> est encore au\nstade 3 (candidate) à l'heure de cet article. Mais il ne fait plus aucun doute\nqu'elle (ou une variante) fera partie de la spécification ES2016.</p>\n<h2>Fonctions asynchrones</h2>\n<p>Pour les traitements asynchrones, vous connaissez déjà\n<a href=\"/fr/articles/js/es2015/promises/\">les promesses</a> qui ont évidemment remplacé\nles callbacks dans votre code. Si vous n'avez pas déjà fait la bascule vers les\npromesses (ne serait-ce que pour la propagation d'erreur),\n<a href=\"/fr/articles/js/es2015/generators/\">les générateurs</a> ont dû finir de vous\nconvaincre grâce aux\n<a href=\"/fr/articles/js/es2015/generators/#use-case-co-routines\">coroutines</a>.</p>\n<p>Nous allons voir aujourd'hui une nouvelle manière de traiter les fonctions\nasynchrones. Mais ne jetez pas vos promesses, tout tourne encore autour d'elles.</p>\n<h2>Exemple de traitement asynchrone : Promise</h2>\n<p>Partons du programme suivant exécuté le 6 décembre dernier dont l'API est basée\nsur les promesses :</p>\n<ul>\n<li>Il récupère tous les utilisateurs prénommés Nicolas</li>\n<li>Il envoie un mail à chacun pour souhaiter bonne fête</li>\n</ul>\n<pre><code class=\"language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sendEmails</span>(<span class=\"hljs-params\">query</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> usersP = getUsers(query);\n  <span class=\"hljs-comment\">// On récupère le champ &quot;email&quot; de tous les utilisateurs</span>\n  <span class=\"hljs-keyword\">const</span> emailsP = usersP.then(<span class=\"hljs-function\"><span class=\"hljs-params\">users</span> =&gt;</span> users.map(<span class=\"hljs-function\"><span class=\"hljs-params\">u</span> =&gt;</span> u.email));\n  <span class=\"hljs-comment\">// Pour chaque email…</span>\n  <span class=\"hljs-keyword\">const</span> sentP = emailsP.then(<span class=\"hljs-function\"><span class=\"hljs-params\">emails</span> =&gt;</span>\n    emails.map(<span class=\"hljs-function\"><span class=\"hljs-params\">email</span> =&gt;</span> {\n      <span class=\"hljs-comment\">// … on envoie un mail</span>\n      <span class=\"hljs-keyword\">return</span> sendMail(email, <span class=\"hljs-string\">&quot;Bonne fête&quot;</span>);\n    }),\n  );\n  <span class=\"hljs-comment\">// On attend que tous les envois soient résolus</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Promise</span>.all(sentP);\n}\n\nsendEmails({ <span class=\"hljs-attr\">firstName</span>: <span class=\"hljs-string\">&quot;Nicolas&quot;</span> })\n  .then(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;OK&quot;</span>))\n  .catch(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">console</span>.error(<span class=\"hljs-string\">&quot;FAIL&quot;</span>));\n</code></pre>\n<h2>Nouveaux mot-clés <code>async</code> et <code>await</code></h2>\n<p>Une fonction peut être marquée comme asynchrone lorsque préfixée par <code>async</code> :</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myFunction</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-comment\">// …</span>\n}\n</code></pre>\n<p>Dans une fonction asynchrone, et <strong>seulement</strong> dans une fonction asynchrone, le\nmot-clé <code>await</code> devient disponible. Lorsqu'il est utilisé en préfixe d'une\npromesse, l'évaluation de l'expression est &quot;mise en pause&quot; jusqu'à la résolution\n(ou le rejet) de la promesse :</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myFunction</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">await</span> aPromise;\n  <span class=\"hljs-comment\">// on n&#x27;arrivera à cette ligne que lorsque &quot;aPromise&quot; sera résolue</span>\n}\n</code></pre>\n<p>Évidemment, l'expression a alors pour valeur celle de résolution de la promesse,\net en cas d'erreur l'expression va lever (<code>throw</code>) une erreur :</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myFunction</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">await</span> aPromise;\n    <span class=\"hljs-comment\">// Ici &quot;aPromise&quot; est résolue avec la valeur &quot;result&quot;</span>\n  } <span class=\"hljs-keyword\">catch</span> (err) {\n    <span class=\"hljs-comment\">// Ici &quot;aPromise&quot; est rejetée avec l&#x27;erreur &quot;err&quot;</span>\n  }\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">42</span>; <span class=\"hljs-comment\">// cette ligne n&#x27;est atteinte qu&#x27;après résolution/rejet</span>\n}\n</code></pre>\n<p>Concrètement, si vous vous souvenez de l'article sur les générateurs et de la\npartie sur les coroutines, remplacez <code>async function</code> par <code>function *</code> et\n<code>await</code> par <code>yield</code>, et vous avez compris le principe. ;)</p>\n<h2>Notre premier exemple, avec les fonctions asynchrones</h2>\n<p>Réécrivons notre premier exemple avec des fonctions asynchrones :</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sendEmails</span>(<span class=\"hljs-params\">query</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> users = <span class=\"hljs-keyword\">await</span> getUsers(query);\n  <span class=\"hljs-keyword\">const</span> emails = users.map(<span class=\"hljs-function\"><span class=\"hljs-params\">u</span> =&gt;</span> u.email);\n  <span class=\"hljs-keyword\">const</span> sentP = emails.map(<span class=\"hljs-function\"><span class=\"hljs-params\">email</span> =&gt;</span> sendMail(email, <span class=\"hljs-string\">&quot;Bonne fête&quot;</span>));\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">await</span> <span class=\"hljs-built_in\">Promise</span>.all(sentP);\n}\n\n<span class=\"hljs-comment\">// Attention, on ne peut pas utiliser &quot;await&quot; hors d&#x27;une fonction &quot;async&quot;</span>\n<span class=\"hljs-comment\">// il faut donc &quot;wrapper&quot; notre code autour d&#x27;une fonction asynchrone</span>\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-keyword\">await</span> sendEmails({ <span class=\"hljs-attr\">firstName</span>: <span class=\"hljs-string\">&quot;Nicolas&quot;</span> });\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;OK&quot;</span>);\n  } <span class=\"hljs-keyword\">catch</span> (e) {\n    <span class=\"hljs-built_in\">console</span>.error(<span class=\"hljs-string\">&quot;FAIL&quot;</span>);\n  }\n}\n\nmain();\n</code></pre>\n<p>Mieux ? Moins bien ? Question de goût, mais on retrouve un code impératif plus\nhabituel.</p>\n<h2>Attention au piège de l'exécution en série !</h2>\n<p>Prenons l'exemple de requêtes qu'on exécute en concurrence avant d'utiliser\nleurs résultats :</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">const</span> xP = getX(); <span class=\"hljs-comment\">// Requête Ajax</span>\n<span class=\"hljs-keyword\">const</span> yP = getY(); <span class=\"hljs-comment\">// Requête BDD</span>\n<span class=\"hljs-keyword\">const</span> resultP = <span class=\"hljs-built_in\">Promise</span>.all([xP, yP]).then(sum);\n</code></pre>\n<p>Dans cet exemple, les requêtes sont lancées, exécutées en parallèle puis leurs\nretours attendus avant de passer à la suite.</p>\n<p>Si on le traduit bêtement ainsi, on perd l'aspect concurrentiel :</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">const</span> x = <span class=\"hljs-keyword\">await</span> getX() <span class=\"hljs-comment\">// Requête Ajax…</span>\n<span class=\"hljs-comment\">// … requête terminée !</span>\n<span class=\"hljs-keyword\">const</span> y = <span class=\"hljs-keyword\">await</span> getY() <span class=\"hljs-comment\">// Requête BDD…</span>\n<span class=\"hljs-comment\">// … requête terminée !</span>\n<span class=\"hljs-keyword\">const</span> result = sum([x, y])\n</code></pre>\n<p>Il faudra bien distinguer le moment où on souhaite <strong>démarrer l'action</strong> et le\nmoment où l'on souhaite <strong>disposer de son résultat</strong>, il y a plusieurs manières\nde résoudre le problème, qui dépendent essentiellement du goût du développeur ;)</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">const</span> xP = getX() <span class=\"hljs-comment\">// Requête Ajax démarrée…</span>\n<span class=\"hljs-keyword\">const</span> yP = getY() <span class=\"hljs-comment\">// Requête BDD démarrée…</span>\n\n<span class=\"hljs-comment\">// Version 1 :</span>\n<span class=\"hljs-keyword\">const</span> x = <span class=\"hljs-keyword\">await</span> xP <span class=\"hljs-comment\">// …requête Ajax terminée !</span>\n<span class=\"hljs-keyword\">const</span> y = <span class=\"hljs-keyword\">await</span> yP <span class=\"hljs-comment\">// …requête BDD terminée !</span>\n<span class=\"hljs-keyword\">const</span> result = sum([x, y])\n\n<span class=\"hljs-comment\">// Version 2 avec un tableau :</span>\n<span class=\"hljs-keyword\">const</span> vars = [<span class=\"hljs-keyword\">await</span> xP, <span class=\"hljs-keyword\">await</span> yP]\n<span class=\"hljs-keyword\">const</span> result = sum(vars)\n\n<span class=\"hljs-comment\">// Version 3 avec Promise.all :</span>\n<span class=\"hljs-keyword\">const</span> vars = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-built_in\">Promise</span>.all([xP, yP])\n<span class=\"hljs-keyword\">const</span> result = sum(vars)\n</code></pre>\n<h2>Et aujourd'hui ?</h2>\n<p>On peut utiliser Babel pour compiler son code utilisant <code>async/await</code> en un code\nbasé sur les générateurs : il vous suffira d'ajouter les plugins Babel\n<code>syntax-async-functions</code> et <code>transform-async-to-generator</code> (attention à inclure\n<code>babel-polyfill</code> en fichier d'entrée).</p>\n<h2>Conclusion</h2>\n<p>Grâce aux fonctions asynchrones, la refactorisation d'un code bloquant vers un\ncode non bloquant devient vraiment aisée. Les promesses simplifiaient déjà le\nprocessus mais on n'était pas débarassé des callbacks. Là, à deux mot-clés près,\nc'est exactement la même chose !</p>\n<p>D'un certain côté, c'est un retour en arrière : l'asynchrone mène aux promesses,\nqui mènent à la programmation fonctionnelle, qui apporte tant de bienfaits… Il\ns'agira de trouver le bon équilibre, je ne suis pas convaincu d'abandonner mes\n<code>.then</code> tout de suite, mais il est certain que c'est une véritable avancée pour\nce langage : la courbe d'apprentissage des traitements asynchrones va être\ndrastiquement aplanie ;)</p>\n"}}},"h":1,"l":{"RE_PRIVATE_NONE":true},"r":{"RE_PRIVATE_NONE":true}},"h":1,"l":{"RE_PRIVATE_NONE":true},"r":{"RE_PRIVATE_NONE":true}},"listsRequests":{"data":{"RE_PRIVATE_NONE":true}},"itemsRequests":{"data":{"RE_PRIVATE_NONE":true}}}</script><script defer="defer" src="/public/main.93407df7323d9cd786a3.js"></script></html>