---
date: 2020-11-29
title: "Cr√©er votre propre r√®gle ESLint pour TypeScript: la magie des AST"
author: gomesalexandre
slug: creer-plugin-eslint-typescript-magie-ast
---
Aujourd'hui, d√©couvrons comment cr√©er un plugin ESLint pour √©crire du code √† notre place, et automatiser ce qui prendrait des semaines, voire des mois, manuellement.


<figure>
	<img src="/public/images/articles/2020-11-29-creer-plugin-eslint-typescript-magie-ast/result-gif.gif" />
	<figcaption>Le r√©sultat? Une r√®gle TypeScript ESLint qui ajoutera automatiquement le g√©nerique n√©cessaire √† vos appels vers shallow(), pour ne pas avoir d'erreurs de typage</figcaption>
</figure>


D√©couvrez le monde merveilleux des "AST": ils ne sont pas si difficiles que ce que l'on pourrait croire!

# Pourquoi √©crire vos propres r√®gles ESLint ?

- C'est int√©ressant, et une bonne mani√®re d'approfondir vos connaissances syntaxiques √† propos de JS/TS;

- Cela vous permet de d√©finir des r√®gles quant aux standards du code au sein de votre entreprise;

- Ce sont potentiellement des semaines de travail "manuel" en moins üòÉ.

Il existe d√©j√† plein de r√®gles, dictant [le style de vos accolades](https://eslint.org/docs/rules/brace-style), le fait [que vos fonctions async de ne doivent pas retourner d'expression await](https://eslint.org/docs/rules/no-return-await) ou encore [le fait que vous ne devez pas initialiser vos variables avec la valeur `undefined`](https://eslint.org/docs/rules/no-undef-init).

Le nombre de r√®gles est virtuellement infini. De nouvelles apparaissent quasi chaque semaine, s'adaptant aux nouvelles biblioth√®ques et "bonnes pratiques". Alors, pourquoi ne pas √©crire notre propre r√®gle?

# Le probl√®me que nous allons r√©soudre avec une r√®gle ESLint

Les tutoriels utilisent souvent des examples comme `foo`, `bar` ou `baz`. √áa fait l'affaire, mais pourquoi ne pas r√©soudre une r√©elle probl√©matique?

Si vous avez d√©j√† utilis√© `enzyme` pour tester une codebase TypeScript et React, alors vous savez s√ªrement que les appels vers `shallow` acceptent un g√©n√©rique, qui est votre composant. ex. `shallow<User>(<User {...props})`.

<figure>
	<img src="/public/images/articles/2020-11-29-creer-plugin-eslint-typescript-magie-ast/definitely-typed-shallow-definition.png" />
	<figcaption>La definition de la fonction `shallow` sur DefinitelyTyped</figcaption>
</figure>

OK, mais si on ne passe pas le g√©n√©rique? M√™me si au premier abord √ßa n'a pas l'air de poser probl√®me, vous allez rapidement remarquer des erreurs en voulant utiliser les m√©thodes, les propri√©t√©s, ou l'√©tat de votre composant. C'est normal: TypeScript consid√®re votre composant comme un "composant g√©n√©rique", sans signature, sans m√©thodes, rien!

![](/public/images/articles/2020-11-29-creer-plugin-eslint-typescript-magie-ast/tsc-tests-error.png)

La solution est d'ajouter `VotreComposant` (ici, `User`) en tant que g√©nerique: `shallow<User>(<User {...props />)`. Pas de souci s'il s'agit de l'√©crire une fois et que vous √™tes √† l'aise avec TypeScript, par contre √ßa devient probl√©matique si:

- vous venez de finir une migration JS -> TS, avec une codebase pas ou peu typ√©e pour le moment,

- vous venez de finir une migration flow -> TS, avec des typages diff√©rents / manquants maintenant que vous aves du TS

- vous √™tes un nouveau contributeur sur une codebase TS et/ou n'avez jamais touch√© √† un g√©n√©rique.

L'option 2, c'est celle que nous avons eu au sein de notre √©quipe, et une r√®gle ESLint avec un autofix a permis de gagner plusieurs journ√©es qui auraient √©t√© pass√©es √† ajouter les typings manuellement.

## Comment fonctionne ESLint? La magie des AST

Avant de commencer, il est imp√©ratif de comprendre le concept d'AST.

Les **AST** - Abstract Syntax Trees, ou Arbres Syntaxiques Abstraits (ASA) en fran√ßais- sont une repr√©sentation de votre code sous forme d'arbre, qui peut √™tre:
- lu
- manipul√© pour g√©n√©rer un nouvel AST;
- transform√© en code machine qui sera ensuite ex√©cut√©;
- retransform√© en code.

Voire m√™me un m√©lange de tout √ßa!

Par exemple, la bibliot√®que `flow-to-ts` convertit un projet flow en TypeScript de la fa√ßon suivante:


Pour citer [Jason Williams](https://twitter.com/jason_williams), auteur du moteur JS `boa` √©crit en rust:
> On divise notre code en diff√©rents tokens en fonction de leur sens (analyse lexicale), puis on les envoie par groupes √† un parseur qui va g√©n√©rer des expressions(analyse syntaxique), qui elles-m√™me peuvent contenir d'autres expressions
> -- <cite> Jason Williams - [Let‚Äôs build a JavaScript Engine in Rust @ JSConf EU 2019](https://youtu.be/_uD2pijcSi4?t=356)</cite>

√áa vous rappelle quelque-chose? C'est plus ou moins la m√™me id√©e que votre HTML transform√© en n≈ìuds DOM, que vous pouvez lire, traverser, et manipuler √† foison!

Assez de th√©orie, prenons un cas concret:
```js
	const user = {
	  id: "unique-id-1",
	  name: "Alex",
	};
```
Ce code peut √™tre repr√©sent√© de cette mani√®re sous forme d'AST:

<figure>
	<img src="/public/images/articles/2020-11-29-creer-plugin-eslint-typescript-magie-ast/example-ast.png" />
	<figcaption>Repr√©sentation sous forme d'AST de notre code gr√¢ce √† astexplorer.net</figcaption>
</figure>

Cette capture vient de l'excellent outil [https://astexplorer.net](https://astexplorer.net/). Il permet de visualiser en d√©tail les AST pour de nombreux langages.
Essayez de poster diff√©rents bouts de code, JS, TS, ou m√™me un autre langage support√©, vous allez voir c'est passionnant!
> Attention: S√©lectionnez le bon langage pour qu'il puisse √™tre pars√©!

# Cr√©ation d'un projet √† linter
> **Si vous avez d√©j√† un projet React + TS + enzyme, vous pouvez passez √† l'√©tape suivante!**

Le but est ici de cr√©er un projet tout simple React + TypeScript + Jest + Enzyme project, qui aura les erreurs TS que nous avons expliqu√© en intro.

Dans l'id√©e, parser du TS, c'est comme parser du JS, il nous faut juste le bon parseur. Pas de souci, le plugin `typescript-eslint` a son [propre parseur TS](https://github.com/typescript-eslint/typescript-eslint/tree/master/packages/parser). Alors, c'est parti!

Cr√©ez un nouveau dossier `ast-learning` qui contiendra notre projet. Ajoutez-y un fichier `package.json` avec react, jest, enzyme, ESLint, etc:
```json
{
  "name": "ast-learning",
  "version": "1.0.0",
  "description": "Projet d'apprentissage des AST",
  "main": "src/index.js",
  "dependencies": {
    "react": "17.0.0",
    "react-dom": "17.0.0",
    "react-scripts": "3.4.3"
  },
  "devDependencies": {
    "@babel/preset-env": "^7.12.1",
    "@babel/preset-react": "^7.12.5",
    "@types/enzyme": "^3.10.8",
    "@types/enzyme-adapter-react-16": "^1.0.6",
    "@types/jest": "^26.0.15",
    "@types/react": "^16.9.56",
    "@types/react-dom": "^16.9.9",
    "@typescript-eslint/eslint-plugin": "^4.8.1",
    "@typescript-eslint/parser": "^4.8.1",
    "babel-jest": "^26.6.3",
    "enzyme": "3.11.0",
    "enzyme-adapter-react-16": "1.15.5",
    "eslint": "^7.13.0",
    "jest": "^26.6.3",
    "react-test-renderer": "^17.0.1",
    "ts-jest": "^26.4.4",
    "typescript": "3.8.3"
  },
  "scripts": {
    "lint": "eslint ./*.tsx",
    "test": "jest index.test.tsx",
    "tsc": "tsc index.tsx index.test.tsx --noEmit true --jsx react"
  }
}
```

Cr√©ez aussi un fichier `tsconfig.json` avec le strict minimum pour satisfaire le compilateur:
```json
{
  "compilerOptions": {
    "allowSyntheticDefaultImports": true,
    "module": "esnext",
    "lib": ["es6", "dom"],
    "jsx": "react",
    "moduleResolution": "node"
  },
  "exclude": ["node_modules"]
}
```

Enfin, cr√©ez un fichier `.eslintrc.js`, sans r√®gle pour le moment:
```js
	export default {
	  parser: "@typescript-eslint/parser",
	  parserOptions: {
		ecmaVersion: 12,
		sourceType: "module",
	  },
	  plugins: ["@typescript-eslint", "ast-learning"],
	  rules: {},
	};
```

Maintenant que notre projet est pr√™t, il est temps de cr√©er notre premier composant `User`:

```ts
import * as React from "react";

type Props = {};
type State = { active: boolean };

class User extends React.Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { active: false };
  }
  toggleIsActive() {
    const { active } = this.state;
    this.setState({ active: !active });
  }

  render() {
    const { active } = this.state;
    return (
      <div className="user" onClick={() => this.toggleIsActive()}>
        User is {active ? "active" : "inactive"}
      </div>
    );
  }
}

export { User };
```

Et le test qui va bien, `index.test.tsx`:

```ts
import * as React from "react";
import * as Adapter from "enzyme-adapter-react-16";
import * as enzyme from "enzyme";
import { User } from "./index";

const { configure, shallow } = enzyme;

configure({ adapter: new Adapter() });

describe("User component", () => {
  it("should change state field on toggleIsActive call", () => {
    const wrapper = shallow(<User />);
    // @ts-ignore
    wrapper.instance().toggleIsActive();
    // @ts-ignore
    expect(wrapper.instance().state.active).toEqual(true);
  });

  it("should change state field on div click", () => {
    const wrapper = shallow(<User />);
    wrapper.find(".user").simulate("click");
    // @ts-ignore
    expect(wrapper.instance().state.active).toEqual(true);
  });
});
```
Dans votre terminal, lancez `npm i && npx ts-jest config:init && npm run test`. Hein? Aucun souci de compilation? Et oui, les commentaires `// @ts-ignore` sont en fait des directives qui ordonnent au compilateur de fermer les yeux sur les erreurs √† la ligne suivante.

Essayons de les enlever?

**‚ùå Les tests ne sont m√™me plus √©x√©cut√©s, vu que notre TS ne compile pas**

Oh non üòû! Comme nous l'avons vu dans l'intro, il est **possible** de r√©soudre cette erreur manuellement:

```ts
const wrapper = shallow<User>(<User />); // g√©n√©rique ajout√©
```

Mais si vous √™tes ici, c'est bien que vous voulez automatiser tout √ßa, non? üòâ

Le processus pour r√©soudre le probl√™me est ici simple: il faut prendre l'argument avec lequel `shallow` est appell√©, le copier, puis le coller en tant que g√©n√©rique.

Passons aux choses s√©rieuses: c'est l'heure d'√©crire le code qui va √©crire du code √† notre place ü§Ø.

# Si vous pouvez modeler le processus, vous pouvez l'automatiser

Prenez un instant pour penser au code que que vous √©crivez au quotidien. Est-ce que certains processus peuvent √™tre model√©s de fa√ßon √† ce qu'un programme pourrait techniquement g√©n√©rer ce code pour vous? Si oui, vous pouvez:

* √âcrire une **r√®gle ESLint**, soit:
  - sans r√©solution automatique (autofix), pour simplement informer des erreurs en laissant le d√©veloppeur la r√©soudre
  - avec autofix, pour qu'il puisse r√©soudre le probl√®me automatiquement au sein de sa codebase

* √âcrire un "**codemod**". Un concept relativement similaire sur le plan technique, qui ne fonctionne pas sous formes de r√®gles. Ce sont un ensemble de modifications faites pour √™tre appliqu√©es au sein de toute votre codebase, pour par exemple transformer `React.createElement()` en JSX ou encore ajouter le pr√©fixe `UNSAFE_` aux m√©thodes de cycle de vie obsol√®tes (codemods reacts officiels).

Les codemods ont une philosophie diff√©rente et sont plut√¥t lourds: ils ne sont pas faits pour r√©agir √† chaque caract√®re que vous tapez.

C'est donc une r√®gle eslint que nous allons √©crire!

# Cr√©ation d'un projet eslint

Cr√©ez le plugin qui contiendra nos r√®gles en cr√©ant un nouveau dossier `eslint-plugin-ast-learning`, voisin de `ast-learning`:
```
Votre Dossier Parent/
‚îú‚îÄ‚îÄ ast-learning/
‚îú‚îÄ‚îÄ eslint-plugin-ast-learning/
```
> ‚ö†Ô∏è Les plugins eslint sont nomm√©s selon la convention `eslint-plugin-nom-de-votre-plugin-en-anglais` !
> Ici, on est dans le cas d'un tuto mais dans la vraie vie, on aurait pu l'appeller `eslint-plugin-enzyme-typescript` par exemple

Initialisez le projet avec un fichier `package.json` basique:
```json
{
  "name": "eslint-plugin-ast-learning",
  "description": "Notre premier plugin eslint",
  "version": "1.0.0",
  "main": "index.js"
}
```
Et un unique fichier `index.js` avec toutes nos r√®gles, dans notre cas juste une: `require-enzyme-generic`:
```js
import * as React from "react";
import * as Adapter from "enzyme-adapter-react-16";
import * as enzyme from "enzyme";
import { User } from "./index";

const { configure, shallow } = enzyme;

configure({ adapter: new Adapter() });

describe("User component", () => {
  it("should change state field on toggleIsActive call", () => {
    const wrapper = shallow(<User />);
    // @ts-ignore
    wrapper.instance().toggleIsActive();
    // @ts-ignore
    expect(wrapper.instance().state.active).toEqual(true);
  });

  it("should change state field on div click", () => {
    const wrapper = shallow(<User />);
    wrapper.find(".user").simulate("click");
    // @ts-ignore
    expect(wrapper.instance().state.active).toEqual(true);
  });
});
```

Chaque r√®gle contient 2 propri√©t√©s: `meta` et `create`. La doc est dispo [ici](https://eslint.org/docs/developer-guide/working-with-rules), mais en gros:

- `meta` est un object qui contient les infos sur votre r√®gle et r√©pond aux questions, par exemple:

* √Ä quoi sert-elle?

* Peut-elle √™tre r√©solue automatiquement?

* Est-ce juste une r√®gle de style, ou g√©n√®re-t-elle des erreurs qui sont probl√©matiques au bon fonctionnement de votre programme?

* Quel est le lien des docs pour que les devs puissent avoir plus d'infos sur cette r√®gle √† cot√© du message d'erreur?

- `create` est une fonction qui contient la *logique* de la r√®gle. Elle est appel√©e avec un object qui contient des propri√©t√©s qui vous √™tre utiles, list√©es [dans la documentation ESLint](https://eslint.org/docs/developer-guide/working-with-rules#the-context-object).

`create` a en valeur de retour un object o√π les cl√©s peuvent √™tre n'importe quel "token" qui existe pour l'AST qui a √©t√© pars√©. Vous pourrez pour chacun de ces tokens √©crire une logique diff√©rente.

Regardons quelques exemples de tokens ensemble:

* **CallExpression**: une expression qui repr√©sente l'appel d'une fonction, ex.: `shallow()`
* **VariableDeclaration**: la d√©claration d'une variable, mais sans le `const`/ `var`/ `let` qui la pr√©c√®de:
```js
    SomeComponent = () => (<div>Hey there</div>)
```

* **StringLiteral**: Une chaine de caract√®re, litt√©rale: `'test'`

C'est assez abstrait, et le meilleur moyen de se faire une id√©e de ce que sont chacun des tokens dans votre code, les groupes qu'ils forment, c'est d'utiliser ASTExplorer avec diff√©rents bouts de code. En moins de temps qu'il vous en faut pour dire "TypeScript", vous penserez comme un parseur!

## D√©finir quand une r√®gle s'appliquera

![Notre code pass√© dans ASTExplorer](/public/images/articles/2020-11-29-creer-plugin-eslint-typescript-magie-ast/our-code-in-ast-explorer.png)*Notre code pass√© dans ASTExplorer*

Allez dans la partie de gauche sur www.astexplorer.net et s√©lectionnez l'appel vers `shadow()` (ou scrollez la partie de droite en survolant l'arbre jusqu'√† trouver la partie qui mettra l'appel en surbrillance): vous verrez qu'il s'agit d'un type **CallExpression**.

L'expression trouv√©e, nous ajoutons donc la propri√©t√© `CallExpression` √† l'objet retourn√© par la m√©thode `create`:
```js
{
  create: function (context) {
    return {
      CallExpression(node) {
        // TODO: Magic üéâ
      },
    };
  },
}
```
Toute m√©thode que vous d√©clarerez en tant que propri√©t√© de l'objet retourn√© par `create` sera appel√©e par eslint, une fois un n≈ìud correspondant √† cette m√©thode, ici √† chaque `CallExpression` donc.
Un rapide coup d'oeil sur [les docs de Babel](https://babeljs.io/docs/en/babel-types#callexpression), et on peut voir que `CallExpression` contient une propri√©t√© `callee`. Cette propri√©t√©, c'est le nom de la fonction que vous appelez, ici, `shallow`.
On peut donc ajouter une condition qui √©valuera `true` si nous appelons une fonction `shadow`.

```js
CallExpression (node) {
  if ((node.callee.name === 'shallow'))
}
```
On veut aussi √™tre s√ªr que notre r√®gle s'applique uniquement s'il n'y a pas **de g√©n√©rique d√©j√† pr√©sent**. Sur ASTExplorer on peut voir que les g√©n√©riques sont appel√©s `typeArguments`.
Babel a 2 propri√©t√©s identiques, `typeArguments` et `typeParameters`(par souci de compatibilit√©) mais celui qui nous int√©resse est `typeParameters`.
C'est un tableau qui contient nos g√©n√©riques, un tableau d'un seul √©l√©ment dans notre cas donc.
Une petite v√©rification pour √™tre s√ªr qu'il n'y a soit pas de chevrons du tout (`typeParameters === undefined`) ou bien que les chevrons sont pr√©sents mais vides (`!node.typeParameters.length`). On peut utiliser la syntaxe courte pour les deux cas de figure:
```js
if (
	node.callee.name === 'shallow' &&
	!node.typeParameters
)
```

Voil√†! Nous avons la logique de notre erreur, il faut maintenant l'√©mettre

# √âmettre une erreur

Nous allons utiliser la m√©thode `context.report`. [La doc de ESLint](https://eslint.org/docs/developer-guide/working-with-rules#contextreport) nous indique que cette m√©thode sert √† publier une erreur.
Elle est appel√©e avec un objet qui peut contenir plusieurs propri√©t√©s utile, dont 3 qui vous nous √™tre n√©cessaires ici:

* `node` (le noeu actuel). Son utilit√© est double: D'abord, informer eslint **d'o√π** se trouve l'erreur pour pouvoir l'indiquer lorsque le d√©veloppeur lancera `eslint` par ligne de commande ou dans son √©diteur. / highlighted in his IDE with eslint plugin. Mais aussi **quel** est ce node (type, contenu, n≈ìuds descendants..) pour pouvoir le manipuler.

* `message` : Le message que les d√©veloppeurs verront pour cette r√®gle

* `fix` : Notre autofix
```js
CallExpression(node) {
	if (
	  node.callee.name === "shallow" &&
	  !(node.typeParameters && node.typeParameters.length)
	) {
	  context.report({
		node: node.callee, // shallow
		message:
		  `enzyme.${node.callee.name} calls should be preceded by their component as generic. ` +
		  "If this doesn't remove type errors, you can replace it with <any>, or any custom type.",
		fix: function (fixer) {
		  // TODO
		},
	  });
	}
}
```
Voil√†, l'erreur est √©mise üì°!

## √âcrire la m√©thode `fix`

La premi√®re chose que notre r√®gle fera, c'est ins√©rer `<any>` si eslint ne d√©tecte pas d'√©l√©ment JSX comme argument avec lequel `shallow()` est appel√© .

> On utilise  `insertTextAfter` method pour ins√©rer du texte apr√®s le node actuel

```js
const hasJsxArgument = node.arguments && node.arguments.find(
	(argument, i) => i === 0 && argument.type === "JSXElement"
);
if (!hasJsxArgument) {
	fixer.insertTextAfter(node.callee, "<any>");
}
```

Cette v√©rification pass√©e, on sait que l'on a un `JSXElement` comme premier argument de `shallow()`.
On peut donc r√©cup√©rer le nom de cet √©l√©ment et le passer comme g√©n√©rique √† shallow.

```js
    const expressionName = node.arguments[0].openingElement.name.name
    return fixer.insertTextAfter(node.callee, `<${expressionName}>`)
```

<figure>
	<img src="/public/images/articles/2020-11-29-creer-plugin-eslint-typescript-magie-ast/pokemon-captured.webp" />
	<figcaption>F√©licitations! Le nom est captur√©(</figcaption>
</figure>

Il est maintenant temps de v√©rifier si notre r√®gle fonctionne, en l'utilisant avec le projet cr√©√© dans l'√©tape pr√©c√©dente.


## Utiliser des plugins custom dans un projet

De retour dans notre projet `ast-learning`, il est temps d'installer le plugin que nous venons d'√©crire:
```sh
npm install ../eslint-plugin-ast-learning
```
Maintenant que le plugin est install√©, nous allons l'ajouter, ainsi que la r√®gle qu'il contient dans notre `.eslintrc.js`:

```js
module.exports = {
	parser: "@typescript-eslint/parser",
	parserOptions: {
		ecmaVersion: 12,
		sourceType: "module",
	},
	plugins: [
		"@typescript-eslint",
		"ast-learning", // eslint-plugin-ast-learning
	],
	rules: {
		"ast-learning/require-enzyme-generic": "error",
	},
};
```

> Si vous lancez `npm run lint` ou bien que vous ouvrez les tests de `User` dans votre IDE avec un plugin ESLint install√©, vous allez voir les erreurs de lint en question:

```
/Users/alexandre.gomes/Sites/ast-learning/index.test.tsx
  12:21  error  enzyme.shallow calls should be preceeded by their component as generic. If this doesn't remove type errors, you can replace it
 with <any>, or any custom type  ast-learning/require-enzyme-generic
  20:21  error  enzyme.shallow calls should be preceeded by their component as generic. If this doesn't remove type errors, you can replace it
 with <any>, or any custom type  ast-learning/require-enzyme-generic

‚úñ 2 problems (2 errors, 0 warnings)
  2 errors and 0 warnings potentially fixable with the `--fix` option.
```
F√©licitations! Les erreurs contiennent le texte g√©n√©r√© par ESLint, les lignes et caract√®res o√π l'erreur a √©t√© d√©tect√©e... et un message qui nous indique qu'elles peuvent √™tre corrig√©es automatiquement.
Int√©r√©ssant! Relancez le script de lint avec le drapeau `--fix`:
```
npm run lint -- --fix
```
> ‚ÑπÔ∏è `npm run <votreScript> -- <unDrapeau>` permet de passer un drapeau √† votre script npm sans avoir √† le modifier

![](/public/images/articles/2020-11-29-creer-plugin-eslint-typescript-magie-ast/example-ast.png)

Woohoo! Tous nos tests ont √©t√© modifi√©s avec le g√©n√©rique, et il n'y a plus d'erreurs TS. üéâ

Imaginez la m√™me r√®gle avec autofix sur 10, 100, 1000, 10000 fichiers... des journ√©es de travail en moins! ü§Ø

# Pour continuer avec ESLint et les AST

Bien que long, ce tutorial reste une introduction sur les AST et le fonctionnement d'ESLint et ses r√®gles. Si vous souhaitez en savoir plus et cr√©er vos propres r√®gles, leurs docs sont tr√®s bien faites, elles seront votre r√©f√©rence.

Il faudra aussi ajouter des tests *complets* pour chaque r√®gle: d'√©xperience, les corrections automatiques sont sournoises et ont leur lot de cas particuliers qui peuvent potentiellement casser votre codebase.
Les tests ne sont pas juste une condition sine qua non quant √† la qualit√© des r√®gles que vous √©crirez: ils sont la r√®gle pour publier une r√®gle officielle üòâ et il est vivement conseill√© de suivre les m√™mes standards de qualit√©. Et √ßa, que vous souhaitez la contribuer en tant que r√®gle officiel, ou la garder pour votre team!

